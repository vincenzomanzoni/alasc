options
{
STATIC = false; // default TRUE
LOOKAHEAD = 1; // default 1
IGNORE_CASE = true; // default false
}

PARSER_BEGIN(Parser)
package com.google.code.alasc;

import java.io.*;
import java.util.*;

public class Parser {
	
	private StringBuffer flashListing;
	private TreeSet<Symbol> symbolsTable;
	private ArrayList<Error> errors;
	
	// NOTE: non mettere il costruttore di default, non viene chiamato dall'implementazione di
	// parser.java. Bloody JavaCC!!!
		public ArrayList<Error>getErrors()	{	  return errors;	}	public String getCode(){	  return flashListing.toString();	}	public TreeSet<Symbol>getSymbolsTable(){	  return symbolsTable;	}	
	// FIX: lettura pi√π efficiente
    private String loadTemplateSnippet(String url){
    	FileInputStream fis = null;
		try {
			fis = new FileInputStream(url);
		} catch (FileNotFoundException e) {
			System.out.println("Errore nell'apertura del file " + url);
		}
    	InputStreamReader isr = new InputStreamReader(fis);
    	BufferedReader myReader = new BufferedReader(isr);
    	
    	StringBuffer snippet = new StringBuffer();
    	String line = null;
    	
    	try {
			line = myReader.readLine();
		} catch (IOException e) {
			System.out.println("Errore nella lettura del file " + url);
		}
    	String eol = System.getProperty("line.separator");
    	while(line!=null){
    		snippet.append(line);
    		snippet.append(eol);
    		
    		try {
				line = myReader.readLine();
			} catch (IOException e) {
			System.out.println("Errore nella lettura del file " + url);
    		}
    	}
    	
    	return snippet.toString();
    }
    
    // TODO: far ritornare l'esito della compilazione come da UML
    public void parse(){
    	
    	symbolsTable = new TreeSet<Symbol>();
		errors = new ArrayList<Error>();
		flashListing = new StringBuffer();
    	
    	// Inserisco l'intestazione del template
		flashListing.append(loadTemplateSnippet("head.inc"));
		
		// Genero ed inserisco la personalizzazione del template
		try {
			String myCode = start();
			Beautifier b = new SimpleBeautifier(2);
			myCode = b.beautify(myCode);
			
			flashListing.append(myCode);
		} catch(ParseException pe) {
			System.out.println(pe.toString());
		} catch(SemanticException se) {
			System.out.println(se.toString());
		}
		
		// Inserisco la chiusura del template
		flashListing.append(loadTemplateSnippet("tail.inc"));
    }

}
PARSER_END(Parser)

SKIP : { " " | "\t" | "\n" | "\r" }

TOKEN :
{
	<NUM: (["0"-"9"])+>
	| <VARNAME: ":"("_"|["A"-"Z"])("_"|["A"-"Z"]|["0"-"9"])*>
	| <FD: "FD">
	| <BK: "BK">
	| <LT: "LT">
	| <RT: "RT">
	| <CLEAN: "CLEAN">
	| <PENDOWN: "PENDOWN">
	| <PENUP: "PENUP">
	| <COLOR: "COLOR">
	| <SUM: "SUM">
	| <DIFFERENCE: "DIFFERENCE">
	| <PRODUCT: "PRODUCT">
	| <QUOTIENT: "QUOTIENT">
	| <MAKE: "MAKE">
	| <LET: "LET">
	| <LESS: "LESS?"> 
	| <GREATER: "GREATER?">
	| <EQUAL: "EQUAL?">
	| <NOTEQUAL: "NOTEQUAL?">
	| <IF: "IF">
	| <REPEAT: "REPEAT">
	| <LBRACKET: "[">
	| <RBRACKET: "]">
}

// TODO SUPERIMPORTANTE!!! USARE EBNF!!!
String start() throws SemanticException : {String list;}
{ 
	list = lista()
	{
		return list;
	}
}

// TODO COME SOPRA!
String lista() throws SemanticException : {String corr, succ;}
{
	corr = istr() succ = lista()
	{
		return corr + succ;
	}
	|
	{
		return "";
	}
}

String istr() throws SemanticException : {String op;}
{ 
	op = dr_op()
	{
		return op;
	} 
	|
	op = var_op()
	{
		return op;
	}
	|
	op = ctrl_str()
	{
		return op;
	}
}

String dr_op() throws SemanticException : {String expr;}
{
	<FD> expr=n_value()
	{
		return "goForward(" + expr + ");";
	}
	|
	<BK> expr=n_value()
	{
		return "goBackward(" + expr + ");";
	}
	|
	<LT> expr=n_value()
	{
		return "rotateLeft(" + expr + ");";
	}
	|
	<RT> expr=n_value()
	{
		return "rotateRight(" + expr + ");";
	}
	|
	<COLOR> expr=n_value()
	{
		return "setColor(" + expr + ");";
	}
	|
	<CLEAN>
	{
		return "clearScreen();";
	}
	|
	<PENDOWN>
	{
		return "penDown();";
	}
	|
	<PENUP>
	{
		return "penUp();";
	}
}

String n_value() throws SemanticException : {String expr;}
{
	expr=n_oper()
	{
		return expr;
	}
	|
	expr=n_s_value()
	{
		return expr;
	}
}

String n_s_value() throws SemanticException : {Token t;}
{
	t=<VARNAME>
	{
		String varname = t.image.substring(1);
		
		// TODO: creare una funzione che esegue il controllo
		// TODO: controlla l'inizializzazione delle variabili
		if(!symbolsTable.contains(new Symbol(varname))) {
			throw new SemanticException("The symbol " + varname + " isn't declared yet.");
		}
		
		return varname;
	}
	|
	t=<NUM>
	{
		return t.image;
	}
}

String n_oper() throws SemanticException : {String expr1,expr2;}
{
	<SUM> expr1=n_s_value() expr2=n_s_value()
	{
		return expr1 + " + " + expr2;
	}
	|
	<DIFFERENCE> expr1=n_s_value() expr2=n_s_value()
	{
		return expr1 + " - " + expr2;
	}
	|
	<PRODUCT> expr1=n_s_value() expr2=n_s_value()
	{
		return expr1 + " * " + expr2;
	}
	|
	<QUOTIENT> expr1=n_s_value() expr2=n_s_value()
	{
		return expr1 + " / " + expr2;
	}
}

String var_op() throws SemanticException : {Token v,n=null;String expr,varname;}
{
	<MAKE> v=<VARNAME> (n=<NUM>)?
	{
		// TODO: Controllo tabella dei simboli
		
		// Toglie i ":" iniziali dal nome della variabile
		varname = v.image.substring(1);

		if (!symbolsTable.add(new Symbol(varname))) {
			throw new SemanticException("The symbol " + varname + " is already declared.");
		} 
		
		if (n != null) {
			return "var " + varname + " : Number = " + n.image + ";";
		}
		else {
			return "var " + varname + " : Number;";
		}
	}
	|
	<LET> v=<VARNAME> expr=n_value()
	{	
		// Toglie i ":" iniziali dal nome della variabile
		varname = v.image.substring(1);
		
		if(!symbolsTable.contains(new Symbol(varname))) {
			throw new SemanticException("The symbol " + varname + " isn't declared yet.");
		}
		
		return varname + " = " + expr + ";";
	}
}

String b_oper() throws SemanticException : {String expr1,expr2;}
{
	<LESS> expr1=n_s_value() expr2=n_s_value()
	{
		return expr1 + " < " + expr2;
	}
	|
	<GREATER> expr1=n_s_value() expr2=n_s_value()
	{
		return expr1 + " > " + expr2;
	}
	|
	<EQUAL> expr1=n_s_value() expr2=n_s_value()
	{
		return expr1 + " == " + expr2;
	}
	|
	<NOTEQUAL> expr1=n_s_value() expr2=n_s_value()
	{
		return expr1 + " != " + expr2;
	}
}
	
String ctrl_str() throws SemanticException : {String v,l;}
{
	<IF> v = b_oper() <LBRACKET> l = lista() <RBRACKET>
	{
		return "if ( " + v + " ) {" + l + "}";
	}
	|
	<REPEAT> v = n_value() <LBRACKET> l = lista() <RBRACKET>
	{
		return "for (var $i : Number = 0; $i < (" + v + ") ; $i++) {" + l + "}";
	}
}
